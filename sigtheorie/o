%! PS
% |+++++++++++++++++++++++++|
% | code generated by psplt |
% |     by akke houben      |
% |+++++++++++++++++++++++++|

% data arrays:------------------------------------------|
/xdata [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ] def
/ydata [ 3.14159 -2.42201 -2.65582 -3.0065 2.90343 2.52835 2.15715 1.79055 1.42692 1.06309 0.694079 0.311945 -0.0968352 -0.556472 -1.10747 -1.78565 -2.52153 3.12561 2.62832 2.22843 1.89045 1.59514 1.33322 1.10077 0.896617 0.720554 0.571608 0.446355 0.337995 0.237384 0.136046 0.0292893 -0.0823877 -0.193398 -0.293322 -0.366541 -0.392839 -0.356291 -0.272302 -0.202468 -0.203071 -0.283583 -0.428729 -0.622761 -0.856081 -1.12515 -1.43165 -1.78179 -2.18423 -2.64272 ] def
% ------------------------------------------------------|

% options:----------------------------------------------|
/constr_ratio 0 def % aspect ratio x:y = 1:1
/datalabels 0 def   % bool: draw data values (x, y)
/xlabels 1 def      % bool: draw x values
/ylabels 0 def      % bool: draw y values
% ------------------------------------------------------|

% constants:--------------------------------------------|
/margin 8.5 def
/pagewidth 8.5 70 mul def               % pagewidth
 /pageheight 8.5 70 mul 2 sqrt div def    % pageheight
% ------------------------------------------------------|

% initialise:-------------------------------------------|
/pw pagewidth def
/ph pageheight def
/Courier 20 selectfont
% ------------------------------------------------------|

% procedures:-------------------------------------------|
% graphical:
/point { % x y on stack
	/y exch def
	/x exch def
	x y 4 0 360 arc fill
} def   % /point

/line { % x y on stack
	/y exch def
	/x exch def
	x x y
	moveto                       % move to x y
	haxis lineto                 % draw line from x y to x base
} def   % /line

/lbl { % x y i on stack
	/ival exch def  % store i val
	/y exch def     % store y coordinate
	/x exch def     % store x coordinate

	% datalabels:
	datalabels 1 eq {   % datalabels == true?
		/xval xdata i get def     % get x value
		/yval ydata i get def     % get y value
		x y moveto
		xval 20 string cvs show
		(,) show
		yval 20 string cvs show
	} if

	% axis labels:
	xlabels 1 eq {  % xlabels == true?
		/xval xdata i get def
		x haxis 17 sub moveto
		xval 20 string cvs show
	} if
	ylabels 1 eq {  % ylabels == true?
		/yval ydata i get def
		vaxis y moveto
		yval 20 string cvs show
	} if
} def   % /lbl

/datapoint { % x y on stack
	/y exch def
	/x exch def
	newpath
		1 setlinewidth
		x y point       % call point function
		x y line        % call line function
	stroke
} def   % /datapoint
/drawaxis {
	% x axis:
	newpath
		margin haxis moveto
		pagewidth margin sub haxis lineto
		2 setlinewidth
	stroke

	% y axis:
	newpath
		vaxis margin moveto
		vaxis pageheight margin sub lineto
		2 setlinewidth
	stroke
	} def   % /drawaxis

/plot {
	/i 0 def
	xnorm {     % x[i] on stack
		vaxis add       % scale x[i] to pagewidth
		/x exch def     % store x data

		ynorm i get     % get y[i] on stack
		haxis add       % scale y[i] to pageheight
		/y exch def     % store y data

		x y datapoint   % draw data
		x y i lbl       % draw labels
		 /i i 1 add def
	} forall
} def   % /plot

% data rearrangement/queries:
/absmax {  % array on stack
	/arr exch def   % store array
	/mval 0 def     % initiase maxvalue as 0
	 arr {
		2 exp sqrt              % get absolute value
		/val exch def           % store as /val
		val mval gt             % current val > maxval?
		{ /mval val def } if    % store current val as maxval
	} forall
	mval        % return max value
} def   % /max

/limits {   % array on stack
	/arr exch def  % store array
	/max 0 def
	/min 0 def
	arr { /val exch def     % store value
		val max gt          % val > max
		{ /max val def } if     % max = val
		val min lt          % val < min
		{ /min val def } if     % min = val
	} forall
	min max     % return min and max
} def   % /limits

/scaledata {
	xdata absmax /max-x exch def   % define max of abs x-data
	ydata absmax /max-y exch def   % define max of abs y-data
	constr_ratio 1 eq       % constrain aspect ratio = 1?
		{ max-x max-y gt    % get max of max-x and max-y
			{ /max-y max-x def }
			{ /max-x max-y def }
		ifelse
		}
	if

	/xnorm  [ xdata { max-x div pw margin 2 mul sub 2 div mul } forall ] def    % normalise xdata
	/ynorm [ ydata { max-y div ph margin 2 mul sub 2 div mul } forall ] def     % normalise ydata
} def   % /scaledata

/scaleaxis {
	xdata limits    % min and max of xdata on stack
	/xmax exch def  % store max in xmax
	/xmin exch def  % store min in xmin

	ydata limits    % min and max of ydata on stack
	/ymax exch def  % store max in ymax
	/ymin exch def  % store min in ymin

	/haxis
		ymin 0 lt ymax 0 gt and { % min < 0 && max > 0?
			ph 2 div
		} {
			ymin 0 eq   % false; no values < 0?
				{
					margin
					/ynorm [ ynorm { 2 mul } forall ] def
				}
				{ ph margin sub }
			ifelse
		} ifelse
	def % place horizontal axis

	/vaxis
		xmin 0 lt xmax 0 gt and {% min < 0 && max > 0?
			pw 2 div
		} {
			xmin 0 eq   % false: no values < 0?
				{
					margin
					/xnorm [ xnorm { 2 mul } forall ] def
				}
				{ pw margin sub }
			ifelse
		} ifelse
	def % place vertical axis

} def   % /scaleaxis
% ------------------------------------------------------|

% invocation:-------------------------------------------|
scaledata
scaleaxis
drawaxis
plot
% ------------------------------------------------------|
