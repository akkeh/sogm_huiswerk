;;;; ******************************************;;;; ***** MIDI STANDARD FILE HANDLING    *****;;;; ***** omgezet voor MCL 2.0b1 by MK   *****;;;; ***** Made ready for LispWorks by MK *****;;;; ******************************************;;;; 300594 310594 050694 090694mk;;;; op dit moment werkt alleen nog the write functie !!!;;;; 131101 changed PowerBook G3 to PowerBook G4;;;; 180407mk LispWorks;;;; 040309  mk, adapted for MT ;;;; 140214 "Users/michelkoenders/Lisp Output 140214/"(defvar *MyDir* "Users/michelkoenders/Lisp Output 140214/")(setq *MyDir* "Users/michelkoenders/Lisp Output 140214/")(defvar *ticks-per-quarter-note* 96    "midi-clock ticks per quarter note.")(defvar *quarter-note*           50.0  "length in (mseconds * *resolution*) of 1 quarter note mm=120.")(defvar *theMIDITrack*           nil)(defvar *resolution*             10.0  "the resolution in mseconds.")(defun writevarlen (number output-list)  (if (< number 128) (cons number output-list)      (writevarlen* (/ number 128)                    (cons (logand number 127) output-list))))(defun writevarlen* (number output-list)  (setf number (truncate number))  (if (< number 128) (cons (+ 128 number) output-list)      (writevarlen* (/ number 128)                    (cons (+ 128 (logand number 127)) output-list))))(defun readvarlen* (lijst)  (if (= (length lijst) 1) lijst      (cons (- (first lijst) 128) (readvarlen* (rest lijst)))))(defun readvarlen (lijst)  (do ((werklijst (reverse (readvarlen* lijst)) (rest werklijst))       (power 0 (+ power 1))       (output 0))      ((null werklijst) output)    (setq output (+ (* (first werklijst) (expt 128 power)) output))))(defun writelen (x bytelength output)  (cond   ((zerop bytelength) output)   ((zerop x) (writelen x (- bytelength 1) (cons 0 output)))   (t     (writelen (truncate (/ x 256)) (- bytelength 1) (cons (logand 255 x) output)))))(defun readlen (xlijst)  (cond ((zerop (first xlijst)) (readlen (rest xlijst)))        (t  (readlen* (reverse xlijst) 0 0))))(defun readlen* (lijst output power)  (cond ((null lijst) output)        (t (readlen* (rest lijst)                     (+ output (* (first lijst) (expt 256 power)))                     (+ power 1)))));; ************************;; ***** HEADER CHUNK *****;; ************************(defun MThd ()  '(77 84 104 100))(defun headerchunk (ntracks)  "MThd + 0006 + filetype/format = 1."  (append (MThd)          '(0 0 0 6 0 1)          (writelen (+ ntracks 1) 2                    (list 0 *ticks-per-quarter-note*))));; *********************** ;; ***** TEMPO TRACK *****;; ***********************(defun tempo-signature (tempo)  (append (list 0 255 81 3)          (writelen (round (/ 60000000 tempo)) 3 nil)))(defun time-signature (nn dd)  (list 0 255 88 4 nn (truncate (/ (log dd) (log 2)))        24 8))(defun tempotrack (nn dd tempo)  (let ((size (+ (length (time-signature nn dd))                 (length (tempo-signature tempo))                 (length (end-of-track (slot-value *theMIDITrack* 'deltaTimeMax))))))    (append (MTrk)            '(0 0 0)            (list size)               ;; size = length of rest of chunk            (time-signature nn dd)            (tempo-signature tempo)            (end-of-track (slot-value *theMIDITrack* 'deltaTimeMax))))) ;; dtime van laatste event moet variabel worden.;; *****************;; ***** TRACK *****;; *****************(defun MTrk ()  '(77 84 114 107)) ;; characters: M T r k(defun end-of-track (dtime)  (append (writevarlen (truncate dtime) nil)          (list 255 47 0)))  ;; EOT(defun miditrack (lijst channel midifilename)  (declare (ignore channel))  (let ((subtotaallijst (append                          (cons 0 (textcode midifilename)) ;; filename = trackname !!!!                         lijst                          (end-of-track 0))))    (append (MTrk)            (writelen (length subtotaallijst) 4 nil)            subtotaallijst)));; **********************;; ***** MIDI CLOCK *****;; **********************(defun clocktodtime (clock)  (writevarlen (round (* *ticks-per-quarter-note*                          (/ (float clock)                             *quarter-note*)))               nil));; ***********************;; ***** META EVENTS *****;; ***********************;; ***** TEXT EVENT (meta event 1)(defun textcode (text-str)  (let* ((str (char-code-of-string text-str))         (metaeventheader (append '(255 1) (writevarlen (length str) nil))))    (nconc metaeventheader str)));; ***** LYRICS (meta event 5)(defun lyric (text-str)  "format : 225 1 length text"  (let* ((str (char-code-of-string text-str))         (metaeventheader (append '(255 5) (writevarlen (length str) nil))))    (nconc metaeventheader str)))(defun char-code-of-string (str)  (let ((TL '()))    (dotimes (i (length str))      (setf TL (append TL (list (char-code (char str i))))))    TL));; **************** CLOS **************************************(defclass CACMIDITrack ()  ((MIDITrackStartTime :initform 0.0 :initarg :MIDITrackStartTime :accessor MIDITrackStartTime)   (NoteOnL          :initform nil :initarg :NoteOnL          :accessor NoteOnL)   (NoteOffL         :initform nil :initarg :NoteOffL         :accessor NoteOffL)   (absTimeNoteOn    :initform 0.0 :initarg :absTimeNoteOn    :accessor absTimeNoteOn)   (deltaTimeNoteOff :initform 0.0 :initarg :deltaTimeNoteOff :accessor deltaTimeNoteOff)   (deltaTimeMax     :initform 0.0 :initarg :deltaTimeMax     :accessor deltaTimeMax)   (MIDIStream       :initform nil :initarg :MIDIStream       :accessor MIDIStream)   (MIDITrackHeader  :initform nil :initarg :MIDITrackHeader  :accessor MIDITrackHeader)))(defun TranslateCACEvntstoSTDMIDIfile (AllCACEvents)  (setf *theMIDITrack* (make-instance 'CACMIDITrack))  (dolist (i AllCACEvents)    (Make-MIDINotelist *theMIDITrack* i))  (MergeMIDINoteOnandNoteOff *theMIDITrack*)  (append (absTime-To-Dtime            (slot-value *theMIDITrack* 'MIDIStream))))(defmethod Make-MIDINotelist ((standard-class CACMIDITrack) CAConeEvent) ;; format (dst pitch veloc dur)  (incf (slot-value *theMIDITrack* 'absTimeNoteOn)(nth 0 CAConeEvent))  (setf (slot-value *theMIDITrack* 'deltaTimeNoteOff) (nth 3 CAConeEvent))  (setf (slot-value *theMIDITrack* 'NoteOnL)        (append (slot-value *theMIDITrack* 'NoteOnL)                (list                  (list                   (slot-value *theMIDITrack* 'absTimeNoteOn)                  (nth 1 CAConeEvent)                  (nth 2 CAConeEvent)))))  (setf (slot-value *theMIDITrack* 'NoteOffL)        (append (slot-value *theMIDITrack* 'NoteOffL)                (list                  (list                   (+ (slot-value *theMIDITrack* 'absTimeNoteOn)                     (slot-value *theMIDITrack* 'deltaTimeNoteOff))                  (nth 1 CAConeEvent)                  (nth 2 CAConeEvent)))))  (setf (slot-value *theMIDITrack* 'deltaTimeMax)        (+ (slot-value *theMIDITrack* 'absTimeNoteOn)           (slot-value *theMIDITrack* 'deltaTimeNoteOff))))(defmethod MergeMIDINoteOnandNoteOff ((standard-class CACMIDITrack))  ;; first translation !!!!  (setf (slot-value *theMIDITrack* 'NoteOnL)        (translatetoMIDI* (slot-value *theMIDITrack* 'NoteOnL)                          'noteon 1)        (slot-value *theMIDITrack* 'NoteOffL)        (translatetoMIDI* (slot-value *theMIDITrack* 'NoteOffL)                          'noteoff 1))  (setf (slot-value *theMIDITrack* 'MIDIStream)        (sort (append (slot-value *theMIDITrack* 'NoteOnL)                      (slot-value *theMIDITrack* 'NoteOffL))              #'< :key #'first)))(defun translatetoMIDI* (oneList MIDIflag midichan) ;; abst pitch veloc  (let ((TL nil))    (if (eq MIDIflag 'noteon)      (dolist (i oneList)        (setf TL (append TL (list                              (list                              (nth 0 i)                              (+ 143 midichan)                              (round (nth 1 i))                              (round (nth 2 i))))))))    (if (eq MIDIflag 'noteoff)      (dolist (i oneList)        (setf TL (append TL (list                              (list                              (nth 0 i)                              (+ 127 midichan) ;; 127                              (round (nth 1 i))                              (round (nth 2 i)))))))) ;; (nth 2 i)    ;; hier kunnen we in theorie nog meer common midi commands kwijt.!!!!!!!    TL))(defun absTime-To-Dtime (L)  (let* ((TL          (car L))         (prevabsTime (nth 0 TL))         (absTime     0.0))         (setf (elt TL 0) (clocktodtime (+ (nth 0 TL)                                      (slot-value *theMIDITrack* 'MIDITrackStartTime))))    (setf TL (pop-1sublists (append (list (car TL)(cdr TL)))))    ;;(format t "~D  ~D~%" (car TL) (- absTime prevabsTime))    (dolist (i (cdr L))      (setf absTime (nth 0 i))      (setf TL (append TL                        (clocktodtime (- absTime prevabsTime))                       (nthcdr 1 i)))      ;;(format t "~D  ~D~%" i (- absTime prevabsTime))      (setf prevabsTime absTime))    TL));; **********************;; ***** POP 1 List *****;; **********************(defun pop-1sublists (L)"pop's one sublist."  (let ((ret nil))    (map 'list          #'(lambda (x)             (declare (ignore x))             (if (not (eq L nil))   ;; 060708 mk - was (neq L nil) didn't work in LispWorks.               (setf ret (append ret (pop L)))))         L)    ret));; ******************************;; ***** TOP-LEVEL FUNCTION *****;; ******************************(defun write-to-stdmidi-file (nn dd tempo midichannel midifilename)  "format nlist : n rhythmdata pitchdata velocitydata channel."  (let (len headerchunk-list tempotrack-list track-list1 track-list midilijst) ;; alles locale variabelen !           ;; ***** dan de tracks aanmaken  ;;   (setf *track-list1* (append                         ;; format: Delta Startime - Midi Note number - Velocity - duration ;;                      (TranslateCACEvntstoSTDMIDIfile '((0 60 127 6.25) ;;                                                        (400 65 127 12.5) ;; delta starttime = 400 ticks =  2 secs ;;                                                        (400 70 127 25) ;;                                                        (400 75 127 50) ;;                                                        (400 80 120 1) ;;                                                        (400 80 70 15) ;;                                                        (400 80 80 200) ;; duration 200 ticks = 1 sec ;;                                                        (400 80 127 400) ;; duration 400 ticks = 2 secs ;;                                                        ))))    (setf track-list1 *track-list1*) ;; bind global to local - random acces    (setf track-list (append (miditrack track-list1 midichannel midifilename)))        (setf headerchunk-list (headerchunk 1))           ;;; ntracks voorlopig 1 track (ntracks)    (setf tempotrack-list (tempotrack nn dd tempo))   ;;; 4 4 120 (nn dd tempo)        (setf midilijst (nconc headerchunk-list tempotrack-list track-list))        ;; ***** dan de midifile samenstellen en de boel saven naar disk    (setf len (length midilijst))    (with-open-file (ofile                      (concatenate 'string *MyDir* midifilename)                     :direction :output                     :if-exists :rename                     :if-does-not-exist :create                     :element-type 'unsigned-byte) ;; was signed-byte      (dotimes (n len)        (write-byte (nth n midilijst) ofile)))    ;;   (set-mac-file-creator (concatenate 'string *MyDir* midifilename) 'FIN3)    ;; werkt niet in LispWorks    ;;   (set-mac-file-type (concatenate 'string *MyDir* midifilename) "Midi"))     ;; idem checken hoe dit in LispWorks heet .mid    )  (format t "~%ready with writing data to midifile ~s~%" (concatenate 'string *MyDir* midifilename)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TOPLEVEL FUNCTION USE IN LISTENER;; (write-to-stdmidi-file 4 4 120 1 "MyMIDIFile.mid")(format t "STDMIDIFILE~%")